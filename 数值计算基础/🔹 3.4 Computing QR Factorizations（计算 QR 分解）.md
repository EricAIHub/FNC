## 🌟 为什么我们要具体算 QR 分解？

QR 分解是求解 **最小二乘** 和 **线性方程组** 的稳健工具。相比通过正规方程求解最小二乘问题，QR 分解数值上 **更稳定、误差更小**。  
为了在计算机上高效实现 QR，我们不能再用不稳定的 Gram-Schmidt，而要用 **正交变换** 来一步步构造上三角矩阵。

---

## 🌟 核心策略：用 **Householder 反射** 引入零

我们希望把矩阵不断变换成上三角形式，这样就能像 LU 分解那样用回代解方程。

要做到这一点，我们采用 **Householder 反射（Householder reflection）**：

$$
P = I - 2vv^T
$$


其中 $\mathbf{v}$ 是单位向量，这个变换：

- 是 **正交矩阵**（$P^T P=I$）
    
- 可以把某个向量映射成只含一个非零元素的形式  
    （即把一列的下方全部变成 0）
    

---

## 🌟 Householder 反射的构造

给定一个向量 $\mathbf{z}$，我们希望找到一个反射，把 $\mathbf{z}$ 变成只有第一分量非零的形式：

$$
P^T P = I
$$


构造方法：

1. 设
    
    $$
P\mathbf{z} = \|\mathbf{z}\|\,\mathbf{e}_1
$$

1. 归一化：
    
    $$
\mathbf{v} = \frac{\mathbf{w}}{\|\mathbf{w}\|}
$$

1. 定义反射矩阵：
    
    $$
P = I - 2\mathbf{v}\mathbf{v}^T
$$


这个 $P$ 就是把 $\mathbf{z}$ 映射到 $|\mathbf{z}|,\mathbf{e}_1$ 的 Householder reflector。

---

## 🌟 如何用 Householder 反射求 QR

我们要把矩阵 $A$ 变成上三角矩阵，同时保持不破坏已做的列结构。

步骤：

1. **第 1 列置零**  
    用反射把第 1 列下方全部变成 0。  
    选取 $\mathbf{z}=A[:,1]$，构造 $P_1$，然后：
    
    $$
A \leftarrow P_1 A
$$

1. **第 2 列置零**  
    为了不破坏第一列的零，我们只对第 2 行往下的部分再做反射。  
    令 $\mathbf{z}=A[2:m,2]$，构造 $P_2$，只作用到后面行：
    
    $$
A[2:m,:] \leftarrow P_2 A[2:m,:]
$$

1. **迭代处理所有列**  
    按同样方式对后续列做反射，直到第 $n$ 列。最终矩阵变为上三角形式：
    
    $$
R = \text{upper triangular}(A)
$$


每一步使用的反射都是正交的，所有反射的叠乘仍然是正交矩阵。最终我们得到：

$$
Q^T = P_n P_{n-1} \cdots P_1
$$


所以：

$$
A = QR
$$


其中 $Q = (P_n \cdots P_1)^T$ 是正交矩阵，$R$ 是上三角矩阵。你不需要实际构造所有的 $P_k$，也不需要显式计算 $Q$，只要在实现中按列逐块作用这些反射即可。

---

## 🌟 为什么这种方法数值稳定？

- **正交变换不放大误差**：反射矩阵 $P$ 是正交的，所以不会增大向量的 2-范数。
    
- **误差控制好**：相比 Gram-Schmidt 算法（容易受舍入误差干扰），Householder 法在实际计算中更稳定，适合数值线性代数实际使用。
    

---

## 🌟 Julia 中的实现

书中给出了一个 Julia 函数 `qrfact(A)` 的示例：

```
function qrfact(A)
    m,n = size(A)
    Qt = diagm(ones(m))
    R = float(copy(A))
    for k in 1:n
        z = R[k:m,k]
        w = [-sign(z[1])*norm(z) - z[1]; -z[2:end]]
        nrmw = norm(w)
        if nrmw < eps() continue; end  # skip
        v = w / nrmw
        # Apply reflection to R and Q
        for j in k:n
            R[k:m,j] -= v*( 2*(v'*R[k:m,j]) )
        end
        for j in 1:m
            Qt[k:m,j] -= v*( 2*(v'*Qt[k:m,j]) )
        end
    end
    return Qt', triu(R)
end
```

这段代码：

- **循环每列**，构造每次的 Householder 向量 $v$
    
- **用 $v$ 更新 R 和 Q$^T$**
    
- 返回正交矩阵 $Q$ 和上三角矩阵 $R$（后者通过 `triu` 提取）
    

这是一个典型的 Householder QR 实现示例。

---

## 🌟 为什么我们通常不会显式构造 $Q$？

正交矩阵 $Q$ 可能非常大（$m\times m$）。而在最小二乘问题中，我们只需要：

$$
Q^T \mathbf{b}
$$



所以可以**不用构造完整的 $Q$**，只需把反射逐个作用于 $b$ 即可得到 $Q^T b$。这种方法在实际代码中更省内存、更快。

---

## 🌟 算法成本（直觉）

- QR 解最小二乘通常比正规方程更稳定，但算量也略大。
    
- Householder QR 的主循环对一个 $m\times n$ 矩阵大致是 $O(mn^2)$。  
    （因为每列反射大约做 $O(m)$ 规模的操作，共 $n$ 列）  
    这是与其他 QR 算法一致的成本量级。
    

---

## 🌟 本节必须记住的核心结论

|核心点|要义|
|---|---|
|**Householder 反射定义**|$P=I-2vv^T$ 是正交且用于反射向量|
|**QR 构造思路**|逐列用反射把矩阵化为上三角|
|**正交不放大误差**|数值稳定性比 Gram-Schmidt 高|
|**不必构造完整 Q**|在最小二乘和解线性系统时可以只用 $Q^T b$|
|**实现要领**|用 Householder 向量逐列更新 R 和（必要时）Q|